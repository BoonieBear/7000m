//////////////////////////////////////////////////////////////////////
// File - lpt_lib.c
//
// Library for accessing the LPT card.
// Code was generated by DriverWizard v6.21 - http://www.jungo.com.
// The library accesses the hardware via WinDriver functions.
// 
// Copyright (c) 2004 Jungo Ltd.  http://www.jungo.com
// 
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "lpt_lib.h"
#include "LPTinclude/windrvr_int_thread.h"
#include "LPTinclude/status_strings.h"
#include "LPTinclude/windrvr.h"
#ifndef __KERNEL__
	#include <stdio.h>
#endif

// If an error occurs, this string will be set to contain a relevant error message
CHAR LPT_ErrorString[1024];

// internal data structures
typedef struct
{
    WD_INTERRUPT Int;
    HANDLE hThread;
    LPT_IntA_HANDLER funcIntHandler;
} LPT_IntA_INTERRUPT;

typedef struct LPT_STRUCT
{
    HANDLE hWD;
    LPT_IntA_INTERRUPT IntA;
    WD_CARD_REGISTER cardReg;
} LPT_STRUCT;

// internal function used by LPT_Open()
void LPT_SetCardElements(LPT_HANDLE hLPT);

// Function: LPT_Open()
//   Register an ISA card to enable working with it.
//   The handle returned from this function is used by most of the functions in this file.
// Parameters:
//   phLPT [out] returns the handle to the opened card.
// Return Value:
//   TRUE if the card was opened successfully. FALSE if there were any errors.
BOOL LPT_Open (LPT_HANDLE *phLPT)
{
    LPT_HANDLE hLPT = (LPT_HANDLE)malloc(sizeof(LPT_STRUCT));

    WD_VERSION ver;
    DWORD dwStatus;

    *phLPT = NULL;
    LPT_ErrorString[0] = '\0';
    if (!hLPT)
    {
        sprintf(LPT_ErrorString, "Failed allocating memory\n");
        return FALSE;
    }
    BZERO(*hLPT);

    dwStatus = LPT_RegisterWinDriver();
    if (dwStatus)
    {
        sprintf(LPT_ErrorString, "Failed registering WinDriver license\n");
        goto Exit;
    }

    hLPT->hWD = WD_Open();

    // Verify that the handle is valid and that the version number is correct
    if (hLPT->hWD==INVALID_HANDLE_VALUE)
    {
        sprintf(LPT_ErrorString, "Failed opening WinDriver device\n");
        goto Exit;
    }

    BZERO(ver);
    WD_Version(hLPT->hWD,&ver);
    if (ver.dwVer<WD_VER)
    {
        sprintf(LPT_ErrorString, "Incorrect WinDriver version. Expected %d.%02d, got %ld.%02ld\n",
             WD_VER/100, WD_VER, ver.dwVer/100, ver.dwVer);
        goto Exit;
    }

    LPT_SetCardElements(hLPT);
    hLPT->cardReg.fCheckLockOnly = FALSE;
    dwStatus = WD_CardRegister(hLPT->hWD, &hLPT->cardReg);
    if (dwStatus)
    {
        sprintf(LPT_ErrorString, "Failed locking device. Status 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Exit;
    }

    BZERO (hLPT->IntA);
    hLPT->IntA.Int.hInterrupt = hLPT->cardReg.Card.Item[LPT_IntA].I.Int.hInterrupt;
    hLPT->IntA.Int.dwOptions = hLPT->cardReg.Card.Item[LPT_IntA].I.Int.dwOptions;

    // LPT_Open() was successful
    *phLPT = hLPT;
    return TRUE;

Exit:
    // An error occured during the execution of LPT_Open()
    if (hLPT->cardReg.hCard) 
        WD_CardUnregister(hLPT->hWD, &hLPT->cardReg);
    if (hLPT->hWD!=INVALID_HANDLE_VALUE)
        WD_Close(hLPT->hWD);
    free (hLPT);
    return FALSE;
}

// Function: LPT_Close()
//   Unregister an opened card.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
// Return Value:
//   None.
void LPT_Close(LPT_HANDLE hLPT)
{
    // disable interrupts
    if (LPT_IntAIsEnabled(hLPT))
        LPT_IntADisable(hLPT);

    // unregister card
    if (hLPT->cardReg.hCard) 
        WD_CardUnregister(hLPT->hWD, &hLPT->cardReg);

    // close WinDriver
    WD_Close(hLPT->hWD);

    free (hLPT);
}

// Function: LPT_RegisterWinDriver()
//   Enter a license string into WinDriver module.
// Parameters:
//   None.
// Return Value:
//   WinDriver status code.
DWORD LPT_RegisterWinDriver(void)
{
    HANDLE hWD;
    WD_LICENSE lic;
    DWORD dwStatus;

    hWD = WD_Open();
    if (hWD==INVALID_HANDLE_VALUE)
        dwStatus = WD_INVALID_HANDLE;
    else
    {
        strcpy(lic.cLicense, "6C3CC2FF76DF316EECA8011E8C7C6D27D725CFF3.www.ayxz.com");
        dwStatus = WD_License(hWD, &lic);
        WD_Close(hWD);
    }
    return dwStatus;
}

void LPT_SetCardElements(LPT_HANDLE hLPT)
{
    WD_ITEMS* pItem;
    hLPT->cardReg.Card.dwItems = LPT_TOTAL_ITEMS;
    pItem = &hLPT->cardReg.Card.Item[0];

    pItem[LPT_IO_Range1].item = ITEM_IO;
    pItem[LPT_IO_Range1].fNotSharable = FALSE;
    pItem[LPT_IO_Range1].I.IO.dwAddr = LPT_IO_Range1_ADDR;
    pItem[LPT_IO_Range1].I.IO.dwBytes = LPT_IO_Range1_BYTES;

    pItem[LPT_IntA].item = ITEM_INTERRUPT;
    pItem[LPT_IntA].fNotSharable = FALSE;
    pItem[LPT_IntA].I.Int.dwInterrupt = LPT_IntA_IRQ;
    pItem[LPT_IntA].I.Int.dwOptions = LPT_IntA_OPTIONS;

}

// General read/write functions

// Function: LPT_ReadWriteBlock()
//   Read/Write data from/to the card's memory/IO into/from a given buffer.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   fRead [in] direction of operation:
//     TRUE indicates read from the card's memory/IO into the given buffer.
//     FALSE indicates write from the given buffer to the card's memory/IO.
//   buf [in/out] a caller allocated buffer to read/write to/from.
//   dwBytes [in] the number of bytes to read/write. The allocated buffer should be at least dwBytes long.
//   mode [in] perform the data transfer byte by byte / word by word / dword by dword.
// Return Value:
//   None.
void LPT_ReadWriteBlock(LPT_HANDLE hLPT, LPT_ADDR addrSpace,
    DWORD dwOffset, BOOL fRead, PVOID buf, DWORD dwBytes, LPT_MODE mode)
{
    WD_TRANSFER trans;
    BOOL fMem = hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY;
    BZERO(trans);
    if (fRead)
    {
        if (mode==LPT_MODE_BYTE) trans.cmdTrans = fMem ? RM_SBYTE : RP_SBYTE;
        else if (mode==LPT_MODE_WORD) trans.cmdTrans = fMem ? RM_SWORD : RP_SWORD;
        else if (mode==LPT_MODE_DWORD) trans.cmdTrans = fMem ? RM_SDWORD : RP_SDWORD;
        else if (mode==LPT_MODE_QWORD) trans.cmdTrans = fMem ? RM_SQWORD : RP_SQWORD;
    }
    else
    {
        if (mode==LPT_MODE_BYTE) trans.cmdTrans = fMem ? WM_SBYTE : WP_SBYTE;
        else if (mode==LPT_MODE_WORD) trans.cmdTrans = fMem ? WM_SWORD : WP_SWORD;
        else if (mode==LPT_MODE_DWORD) trans.cmdTrans = fMem ? WM_SDWORD : WP_SDWORD;
        else if (mode==LPT_MODE_QWORD) trans.cmdTrans = fMem ? WM_SQWORD : WP_SQWORD;
    }
    if (fMem)
        trans.dwPort = hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwTransAddr;
    else trans.dwPort = hLPT->cardReg.Card.Item[addrSpace].I.IO.dwAddr;
    trans.dwPort += dwOffset;

    trans.fAutoinc = TRUE;
    trans.dwBytes = dwBytes;
    trans.dwOptions = 0;
    trans.Data.pBuffer = buf;
    WD_Transfer (hLPT->hWD, &trans);
}

// Function: LPT_ReadByte()
//   Read a Byte from the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
BYTE LPT_ReadByte (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset)
{
    BYTE data;
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        BYTE *pData = (BYTE *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, TRUE, &data, sizeof(BYTE), LPT_MODE_BYTE);
    return data;
}

// Function: LPT_ReadWord()
//   Read a Word from the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
WORD LPT_ReadWord (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset)
{
    WORD data;
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        WORD *pData = (WORD *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, TRUE, &data, sizeof(WORD), LPT_MODE_WORD);
    return data;
}

// Function: LPT_ReadDword()
//   Read a Dword from the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
UINT32 LPT_ReadDword (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset)
{
    UINT32 data;
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        UINT32 *pData = (UINT32 *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, TRUE, &data, sizeof(UINT32), LPT_MODE_DWORD);
    return data;
}

// Function: LPT_ReadQword()
//   Read a Qword from the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
// Return Value:
//   The value read from the card's memory/IO.
UINT64 LPT_ReadQword (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset)
{
    UINT64 data;
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        UINT64 *pData = (UINT64 *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        data = *pData; // read directly from the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, TRUE, &data, sizeof(UINT64), LPT_MODE_QWORD);
    return data;
}

// Function: LPT_WriteByte()
//   Write a Byte to the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void LPT_WriteByte (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset, BYTE data)
{
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        BYTE *pData = (BYTE *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, FALSE, &data, sizeof(BYTE), LPT_MODE_BYTE);
}

// Function: LPT_WriteWord()
//   Write a Word to the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void LPT_WriteWord (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset, WORD data)
{
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        WORD *pData = (WORD *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, FALSE, &data, sizeof(WORD), LPT_MODE_WORD);
}

// Function: LPT_WriteDword()
//   Write a Dword to the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void LPT_WriteDword (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset, UINT32 data)
{
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        UINT32 *pData = (UINT32 *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, FALSE, &data, sizeof(UINT32), LPT_MODE_DWORD);
}

// Function: LPT_WriteQword()
//   Write a Qword to the card's memory/IO.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   addrSpace [in] the address space of the card to access.
//   dwOffset [in] offset relative to the beginning of the address space to access.
//   data [in] the data to write to the card's memory/IO.
// Return Value:
//   None.
void LPT_WriteQword (LPT_HANDLE hLPT, LPT_ADDR addrSpace, DWORD dwOffset, UINT64 data)
{
    if (hLPT->cardReg.Card.Item[addrSpace].item==ITEM_MEMORY)
    {
        UINT64 *pData = (UINT64 *) (hLPT->cardReg.Card.Item[addrSpace].I.Mem.dwUserDirectAddr + dwOffset);
        *pData = data; // write directly to the memory mapped range
    }
    else LPT_ReadWriteBlock(hLPT, addrSpace, dwOffset, FALSE, &data, sizeof(UINT64), LPT_MODE_QWORD);
}

// Function: LPT_Readdata()
//   Read from data register.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
// Return Value:
//   The value read from the register.
BYTE LPT_Readdata (LPT_HANDLE hLPT)
{
    return LPT_ReadByte(hLPT, (LPT_ADDR) LPT_data_SPACE, LPT_data_OFFSET);
}

// Function: LPT_Writedata()
//   Write to data register.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void LPT_Writedata (LPT_HANDLE hLPT, BYTE data)
{
    LPT_WriteByte(hLPT, (LPT_ADDR) LPT_data_SPACE, LPT_data_OFFSET, data);
}

// Function: LPT_Readstatus()
//   Read from status register.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
// Return Value:
//   The value read from the register.
BYTE LPT_Readstatus (LPT_HANDLE hLPT)
{
    return LPT_ReadByte(hLPT, (LPT_ADDR) LPT_status_SPACE, LPT_status_OFFSET);
}

// Function: LPT_Writestatus()
//   Write to status register.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void LPT_Writestatus (LPT_HANDLE hLPT, BYTE data)
{
    LPT_WriteByte(hLPT, (LPT_ADDR) LPT_status_SPACE, LPT_status_OFFSET, data);
}

// Function: LPT_Readcontrol()
//   Read from control register.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
// Return Value:
//   The value read from the register.
BYTE LPT_Readcontrol (LPT_HANDLE hLPT)
{
    return LPT_ReadByte(hLPT, (LPT_ADDR) LPT_control_SPACE, LPT_control_OFFSET);
}

// Function: LPT_Writecontrol()
//   Write to control register.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void LPT_Writecontrol (LPT_HANDLE hLPT, BYTE data)
{
    LPT_WriteByte(hLPT, (LPT_ADDR) LPT_control_SPACE, LPT_control_OFFSET, data);
}

// Function: LPT_IntAIsEnabled()
//   Check if the interrupt is enabled.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
// Return Value:
//   TRUE if the interrupt is enabled. FALSE otherwise.
BOOL LPT_IntAIsEnabled (LPT_HANDLE hLPT)
{
    if (!hLPT->IntA.hThread) return FALSE;
    return TRUE;
}

void DLLCALLCONV LPT_IntAHandler (PVOID pData)
{
    LPT_HANDLE hLPT = (LPT_HANDLE) pData;
    LPT_IntA_RESULT intResult;
    intResult.dwCounter = hLPT->IntA.Int.dwCounter;
    intResult.dwLost = hLPT->IntA.Int.dwLost;
    intResult.fStopped = hLPT->IntA.Int.fStopped;
    hLPT->IntA.funcIntHandler(hLPT, &intResult);
}

// Function: LPT_IntAEnable()
//   Enable the interrupt.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open.
//   funcIntHandler [in] The call back function to be called upon interrupt.
// Return Value:
//   TRUE if the interrupt was successfully enabled. FALSE otherwise.
BOOL LPT_IntAEnable (LPT_HANDLE hLPT, LPT_IntA_HANDLER funcIntHandler)
{
    DWORD dwStatus;

    // Check if interrupt is already enabled
    if (hLPT->IntA.hThread)
        return FALSE;

    // Calls WD_IntEnable() and creates an interrupt handler thread
    hLPT->IntA.funcIntHandler = funcIntHandler;
    dwStatus = InterruptEnable(&hLPT->IntA.hThread, hLPT->hWD, &hLPT->IntA.Int, LPT_IntAHandler, (PVOID) hLPT);
    if (dwStatus)
    {
        sprintf(LPT_ErrorString, "InterruptEnable() failed with status 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    return TRUE;
}

// Function: LPT_IntADisable()
//   Disable the interrupt.
// Parameters:
//   hLPT [in] handle to the card as received from LPT_Open().
// Return Value:
//   None.
void LPT_IntADisable (LPT_HANDLE hLPT)
{
    if (!hLPT->IntA.hThread) return;

    // this calls WD_IntDisable()
    InterruptDisable(hLPT->IntA.hThread);

    hLPT->IntA.hThread = NULL;
}

